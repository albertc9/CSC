//-------------------------------------------------------------------------
// SortUnitFlatRTL__nbits_8.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL Component SortUnitFlatRTL Definition
// At /home/albert/CSC/cpt5/SortUnitFlatRTL.py

module SortUnitFlatRTL__nbits_8
(
  input  logic [0:0] clk ,
  input  logic [7:0] in_ [0:3],
  input  logic [0:0] in_val ,
  output logic [7:0] out [0:3],
  output logic [0:0] out_val ,
  input  logic [0:0] reset 
);
  logic [7:0] elm_S1 [0:3];
  logic [7:0] elm_next_S1 [0:3];
  logic [0:0] val_S1;

  // PyMTL Update Block Source
  // At /home/albert/CSC/cpt5/SortUnitFlatRTL.py:29
  // @update
  // def stage_S1():
  //     # 比较输入数据对 (0,1)
  //     if s.elm_S1[0] <= s.elm_S1[1]:
  //         s.elm_next_S1[0] @= s.elm_S1[0]
  //         s.elm_next_S1[1] @= s.elm_S1[1]
  //     else:
  //         s.elm_next_S1[0] @= s.elm_S1[1]
  //         s.elm_next_S1[1] @= s.elm_S1[0]
  // 
  //     # 比较输入数据对 (2,3)
  //     if s.elm_S1[2] <= s.elm_S1[3]:
  //         s.elm_next_S1[2] @= s.elm_S1[2]
  //         s.elm_next_S1[3] @= s.elm_S1[3]
  //     else:
  //         s.elm_next_S1[2] @= s.elm_S1[3]
  //         s.elm_next_S1[3] @= s.elm_S1[2]
  
  always_comb begin : stage_S1
    if ( elm_S1[2'd0] <= elm_S1[2'd1] ) begin
      elm_next_S1[2'd0] = elm_S1[2'd0];
      elm_next_S1[2'd1] = elm_S1[2'd1];
    end
    else begin
      elm_next_S1[2'd0] = elm_S1[2'd1];
      elm_next_S1[2'd1] = elm_S1[2'd0];
    end
    if ( elm_S1[2'd2] <= elm_S1[2'd3] ) begin
      elm_next_S1[2'd2] = elm_S1[2'd2];
      elm_next_S1[2'd3] = elm_S1[2'd3];
    end
    else begin
      elm_next_S1[2'd2] = elm_S1[2'd3];
      elm_next_S1[2'd3] = elm_S1[2'd2];
    end
  end

  // PyMTL Update Block Source
  // At /home/albert/CSC/cpt5/SortUnitFlatRTL.py:16
  // @update_ff
  // def pipereg_S0S1():
  //     if s.reset:
  //         s.val_S1 <<= 0                    # 复位时清零有效性信号
  //     else:
  //         s.val_S1 <<= s.in_val             # 正常传递有效性信号
  // 
  //     for i in range(4):                    # 输入数据存入寄存器
  //         s.elm_S1[i] <<= s.in_[i]
  
  always_ff @(posedge clk) begin : pipereg_S0S1
    if ( reset ) begin
      val_S1 <= 1'd0;
    end
    else
      val_S1 <= in_val;
    for ( int unsigned i = 1'd0; i < 3'd4; i += 1'd1 )
      elm_S1[2'(i)] <= in_[2'(i)];
  end

endmodule
